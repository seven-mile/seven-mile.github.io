{"componentChunkName":"component---src-templates-blog-post-md-js","path":"/gsoc-2024-project/","result":{"data":{"site":{"siteMetadata":{"title":"7mile"}},"post":{"id":"f5d1688e-8cce-5e84-9688-8587b32b00c6","excerpt":"","source":{"html":"<p>During the last year of my undergraduate studies, I found myself with some extra time and decided to participate in the LLVM community's Google Summer of Code (GSoC) program. My project for the summer was titled <a href=\"https://discourse.llvm.org/t/clangir-compile-gpu-kernels-using-clangir/76984\">Compile GPU kernels using ClangIR</a>. The primary focus of this project was to design a HIR for heterogeneous programming models. In addition to ensuring functional completeness, the work aimed to lay the groundwork for supporting more complex and modern languages like CUDA and SYCL in the future.</p>\n<p>This experience marked my first deep dive into the workings of an open-source community. The ClangIR community, a smaller sub-community within the larger LLVM family, provided a welcoming environment. We have monthly meetings that are relatively informal, making it easier for everyone to communicate and collaborate.</p>\n<h2>Background</h2>\n<p><a href=\"https://github.com/llvm/clangir\">The ClangIR project</a> aims to establish a new IR for Clang, built on top of MLIR. As part of the ongoing effort to support heterogeneous programming models, this project focuses on integrating OpenCL C language support into ClangIR. The ultimate goal is to enable the compilation of GPU kernels written in OpenCL C into LLVM IR targeting the SPIR-V architecture, laying the groundwork for future enhancements in SYCL and CUDA support.</p>\n<h2>What We Did</h2>\n<p>Our work involved several key areas:</p>\n<ol>\n<li>\n<p><strong>Address Space Support</strong>: One of the fundamental tasks was teaching ClangIR to handle address spaces, a vital feature for languages like OpenCL. Initially, we considered mimicking LLVM's approach, but this proved inadequate for ClangIR's goals. After thorough discussion and an RFC, we implemented a unified address space design that aligns with ClangIR's objectives, ensuring a clean and maintainable code structure.</p>\n</li>\n<li>\n<p><strong>OpenCL Language and SPIR-V Target Integration</strong>: We extended ClangIR to support the OpenCL language and the SPIR-V target. This involved enhancing the pipeline to accommodate the latest OpenCL 3.0 specification and implementing hooks for language-specific and target-specific customizations.</p>\n</li>\n<li>\n<p><strong>Vector Type Support</strong>: OpenCL vector types, a critical feature for GPU programming, were integrated into ClangIR. We leveraged ClangIR's existing cir.vector type to generate the necessary code, ensuring consistent compilation results.</p>\n</li>\n<li>\n<p><strong>Kernel and Module Metadata Emission</strong>: We added support for emitting OpenCL kernel and module metadata in ClangIR, a necessary step for proper integration with the SPIR-V target. This included the creation of structured attributes to represent metadata, following MLIR's preferences for well-defined structures.</p>\n</li>\n<li>\n<p><strong>Global and Static Variables with Qualifiers</strong>: We implemented support for global and static variables with qualifiers like <code class=\"language-text\">global</code>, <code class=\"language-text\">constant</code>, and <code class=\"language-text\">local</code>, ensuring that these constructs are correctly represented and lowered in the ClangIR pipeline.</p>\n</li>\n<li>\n<p><strong>Calling Conventions</strong>: We adjusted the calling conventions in ClangIR to align with SPIR-V requirements, migrating from the default <code class=\"language-text\">cdecl</code> to SPIR-V-specific conventions like <code class=\"language-text\">SpirKernel</code> and <code class=\"language-text\">SpirFunction</code>. This also enables most OpenCL built-in functions like <code class=\"language-text\">barrier</code> and <code class=\"language-text\">get_global_id</code>.</p>\n</li>\n<li>\n<p><strong>User Experience Enhancements</strong>: Finally, we ensured that the end-to-end kernel compilation experience using ClangIR was smooth and intuitive, with minimal manual intervention required.</p>\n</li>\n</ol>\n<h2>Results</h2>\n<p>The project successfully met its primary goals. OpenCL kernels from the Polybench-GPU benchmark suite can now be compiled using ClangIR into LLVM IR for SPIR-V. All patches have been merged into the main ClangIR repository, and the project’s progress has been well-documented in the <a href=\"https://github.com/llvm/clangir/issues/689\">overview issue</a>. I believe the work not only advanced OpenCL support but also laid a solid foundation for future enhancements, such as SYCL and CUDA support in ClangIR.</p>\n<p>We have successfully compiled and passed all 20 OpenCL C test cases from the <a href=\"https://github.com/sgrauerg/polybenchGpu\">polybenchGpu</a> repository. Please refer to our <a href=\"https://github.com/seven-mile/clangir-ocl-ae\">artifact evaluation repository</a> for detailed instructions on how to experiment with our work.</p>\n<h2>Future Works</h2>\n<p>As we look forward, there are two key areas that require further development:</p>\n<ol>\n<li>\n<p><strong>Function Attribute Consistency</strong>: For example, the <code class=\"language-text\">convergent</code> function attribute is crucial for preventing misoptimizations in SIMT languages like OpenCL. ClangIR currently lacks this attribute, which could lead to issues in parallel computing contexts. Addressing this is a priority to ensure correct optimization behavior.</p>\n</li>\n<li>\n<p><strong>Support for OpenCL Built-in Types</strong>: Another critical area for future work is the support for OpenCL built-in types, such as <code class=\"language-text\">pipe</code> and <code class=\"language-text\">image</code>. These types are essential for handling data streams and image processing tasks in various specialized OpenCL applications. Supporting these types will significantly enhance ClangIR's adherence to the OpenCL standard, broadening its applicability and ensuring better compatibility with a wide range of OpenCL programs.</p>\n</li>\n</ol>\n<h2>Acknowledgements</h2>\n<p>This project would not have been possible without the guidance and support of the LLVM community. I extend my deepest gratitude to my mentors, Julian Oppermann, Victor Lomüller, and Bruno Cardoso Lopes, whose expertise and encouragement were instrumental throughout this journey. Additionally, I would like to thank Vinicius Couto Espindola for his collaboration on ABI-related work. This experience has been immensely rewarding, both technically and in terms of community engagement.</p>\n<h2>Appendix</h2>\n<ul>\n<li><a href=\"https://github.com/llvm/clangir/issues/689\">Overview issue of OpenCL C support</a></li>\n<li><a href=\"https://github.com/seven-mile/clangir-ocl-ae\">Artifact Evaluation Instructions</a></li>\n</ul>"},"frontmatter":{"title":"Compile GPU kernels using ClangIR","date":"August 29, 2024","description":"My GSoC project this summer"}},"previous":{"slug":"/within-me-a-lunatic-sings/","frontmatter":{"title":"Inní mér syngur vitleysingur"}},"next":{"slug":"/vector-norm-equivalence/","frontmatter":{"title":"Some Thoughts on Vector Norm Equivalence"}}},"pageContext":{"id":"f5d1688e-8cce-5e84-9688-8587b32b00c6","previousPostId":"afc79334-58d1-589c-8203-e82fbde4f614","nextPostId":"12c394f1-03cb-5a2c-a96f-3abe6cd9687d"}},"staticQueryHashes":["2841359383","3660991324","4183435130"],"slicesMap":{}}